package it.unibo.distributedfrp.simulation.simulator.concurrent

import it.unibo.distributedfrp.core.FraspSamples
import it.unibo.distributedfrp.frp.StreamExtension.Stream
import it.unibo.distributedfrp.simulation.environment.{Environment, EnvironmentWithTags}
import it.unibo.distributedfrp.simulation.incarnation.{CommonAlgorithms, CommonSensors, SimulationIncarnation}
import it.unibo.distributedfrp.simulation.simulator.Simulator.WithIncarnation
import it.unibo.distributedfrp.simulation.simulator.SimulatorTest
import it.unibo.distributedfrp.test.utils.executor.ExecutionContextSpy
import it.unibo.distributedfrp.test.utils.time.StopWatch
import it.unibo.distributedfrp.utils.Clock

import java.util.concurrent.Executors
import scala.concurrent.duration.*
import scala.concurrent.{Await, ExecutionContext}

/** Test for [[StepSimulator]]. */
class ConcurrentSimulatorTest extends SimulatorTest:
  private val ConcurrentSimulator = symbol("ConcurrentSimulator")
  private val HaltAfterDurationOf = symbol("haltAfterDurationOf")
  private val HaltAfterInactivityOf = symbol("haltAfterInactivityOf")
  private val HaltWhen = symbol("haltWhen")

  private object Incarnation extends SimulationIncarnation with CommonSensors with CommonAlgorithms with FraspSamples:
    override type Environment = EnvironmentWithTags
  private object Simulator extends ConcurrentSimulator with WithIncarnation(Incarnation) with SimulatorFixture:
    override type Configuration[A] = ConcurrentSimulationConfiguration[A]
    override type SimulationFixture[A] = Simulation[A]
    override def createSimulationFixture[A](flow: incarnation.Flow[A], environment: Environment): SimulationFixture[A] =
      simulation(flow)(using ConcurrentSimulationConfiguration(
        environment = EnvironmentWithTags(environment),
        haltPolicy = HaltPolicy.haltAfterInactivityOf(5.seconds))
      )
    override def executeSimulationFixture[A](simulation: SimulationFixture[A]): Unit = {}
  import Simulator.incarnation.{Environment as _, *, given}

  /**
   * Create a test that runs a simulation and evaluates properties on the
   * events generated by the simulation.
   *
   * @param flow          the flow to be executed in the simulation.
   * @param configuration the configuration of the simulation.
   * @param evaluation    the evaluation to be performed on the events of the
   *                      simulation when it's terminated.
   * @tparam A the type of results produced by the simulation.
   */
  private def concurrentSimulationTest[A](
    flow: Flow[A],
    configuration: Simulator.ConcurrentSimulationConfiguration[A],
    evaluation: Simulator.Simulation[A] ?=> Seq[Simulator.CollectiveResultMap[A]] => Unit,
  ): Unit =
    val simulation = Simulator.simulation(flow)(using configuration)
    val monitor = Stream.monitor(simulation.computedByAll)
    simulation.start()
    Await.ready(simulation.termination, Defaults.timeout)
    evaluation(using simulation)(monitor.eventLog)

  private val maxCount: Int = 10
  private val maxDuration: FiniteDuration = 1.seconds
  private val stopWatch: StopWatch = StopWatch.basic(using Clock.SystemClock)

  ConcurrentSimulator should behave like simulator(Simulator)

  it should "create a simulation that can be executed concurrently by a single thread" in {
    val executor = ExecutionContextSpy(ExecutionContext.fromExecutor(Executors.newSingleThreadExecutor()))
    val environment = EnvironmentWithTags(Environment.euclideanGrid(cols = 10, rows = 10))
    val simulation = Simulator.simulation(count(from = 0, maxCount))(using Simulator.ConcurrentSimulationConfiguration(
      environment = environment,
      haltPolicy = Simulator.HaltPolicy.haltWhen(_ == Seq.range(0, environment.nDevices).map(_ -> maxCount).toMap),
      executor = executor
    ))
    simulation.start()
    Await.ready(simulation.termination, Defaults.timeout)
    executor.maxConcurrency shouldEqual 1
  }

  it should "create a simulation that can be executed concurrently by a multiple threads" in {
    val executor = ExecutionContextSpy(ExecutionContext.global)
    val environment = EnvironmentWithTags(Environment.euclideanGrid(cols = 10, rows = 10))
    val simulation = Simulator.simulation(count(from = 0, maxCount))(using Simulator.ConcurrentSimulationConfiguration(
      environment = environment,
      haltPolicy = Simulator.HaltPolicy.haltWhen(_ == Seq.range(0, environment.nDevices).map(_ -> maxCount).toMap),
      executor = executor,
    ))
    simulation.start()
    Await.ready(simulation.termination, Defaults.timeout)
    executor.maxConcurrency should be >= 1
  }

  HaltAfterDurationOf should
    "terminate a simulation after a given duration " +
    "has elapsed since its start" in concurrentSimulationTest(
    flow = {
      stopWatch.start()
      count(from = 0, to = maxCount)
    },
    configuration = Simulator.ConcurrentSimulationConfiguration(
      environment = EnvironmentWithTags(Environment.singleNode),
      haltPolicy = Simulator.HaltPolicy.haltAfterDurationOf(maxDuration)
    ),
    evaluation = _ => stopWatch.lap() should be >= maxDuration
  )

  HaltAfterInactivityOf should
    "terminate a simulation after a given duration " +
    "has elapsed since its latest event" in concurrentSimulationTest(
    flow = sideEffect(
      flow = count(from = 0, to = maxCount),
      onExport = _ => stopWatch.start()
    ),
    configuration = Simulator.ConcurrentSimulationConfiguration(
      environment = EnvironmentWithTags(Environment.singleNode),
      haltPolicy = Simulator.HaltPolicy.haltAfterInactivityOf(maxDuration)
    ),
    evaluation = _ => stopWatch.lap() should be >= maxDuration
  )

  HaltWhen should
    "terminate a simulation after the collective system " +
    "reaches a specific state" in concurrentSimulationTest(
    flow = count(from = 0, to = maxCount),
    configuration = Simulator.ConcurrentSimulationConfiguration(
      environment = EnvironmentWithTags(Environment.singleNode),
      haltPolicy = Simulator.HaltPolicy.haltWhen(_.get(0).forall(_ >= maxCount))
    ),
    evaluation = _.last shouldEqual Map(0 -> maxCount)
  )
