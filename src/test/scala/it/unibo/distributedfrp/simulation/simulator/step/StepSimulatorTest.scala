package it.unibo.distributedfrp.simulation.simulator.step

import it.unibo.distributedfrp.core.FraspSamples
import it.unibo.distributedfrp.frp.StreamExtension.*
import it.unibo.distributedfrp.simulation.environment.{Environment, EnvironmentWithTags}
import it.unibo.distributedfrp.simulation.incarnation.{CommonAlgorithms, CommonSensors, SimulationIncarnation}
import it.unibo.distributedfrp.simulation.simulator.Simulator.WithIncarnation
import it.unibo.distributedfrp.simulation.simulator.SimulatorTest
import it.unibo.distributedfrp.utils.Liftable.map

/** Test for [[StepSimulator]]. */
class StepSimulatorTest extends SimulatorTest:
  private val StepSimulator = symbol("StepSimulator")
  private val HaltOnVainStep = symbol("haltOnVainStep")
  private val HaltAfter = symbol("haltAfter")
  private val HaltWhen = symbol("haltWhen")

  object Incarnation extends SimulationIncarnation with CommonSensors with CommonAlgorithms with FraspSamples:
    override type Environment = EnvironmentWithTags
  object Simulator extends StepSimulator with WithIncarnation(Incarnation) with SimulatorFixture:
    override type Configuration[A] = StepSimulationConfiguration[A]
    override type SimulationFixture[A] = StepSimulation[A]
    override def createSimulationFixture[A](flow: incarnation.Flow[A], environment: Environment): SimulationFixture[A] =
      simulation(flow)(using StepSimulationConfiguration(
        environment = EnvironmentWithTags(environment),
        haltPolicy = HaltPolicy.haltOnVainStep
      ))
    override def executeSimulationFixture[A](simulation: SimulationFixture[A]): Unit =
      while (simulation.isRunning) { simulation.next() }
  import Simulator.incarnation.{Environment as _, *, given}

  /**
   * Create a test that runs a simulation and evaluates properties on the
   * events generated by the simulation.
   *
   * @param flow          the flow to be executed in the simulation.
   * @param configuration the configuration of the simulation.
   * @param maxSteps      the maximum number of steps to be executed in the
   *                      simulation. If negative or null, the constraint will
   *                      be ignored (default).
   * @param evaluation    the evaluation to be performed on the events of the
   *                      simulation when it's terminated.
   * @tparam A the type of results produced by the simulation.
   */
  private def stepSimulationTest[A](
    flow: Flow[A],
    configuration: Simulator.StepSimulationConfiguration[A],
    maxSteps: Int = Int.MinValue,
    evaluation: Simulator.StepSimulation[A] ?=> Seq[Simulator.CollectiveResultMap[A]] => Unit,
  ): Unit =
    val simulation = Simulator.simulation(flow)(using configuration)
    val monitor = Stream.monitor(simulation.steps)
    simulation.start()
    if maxSteps <= 0 then
      while (simulation.isRunning) { simulation.next() }
    else
      simulation.next(maxSteps)
    evaluation(using simulation)(monitor.eventLog)

  /**
   * @param expectedPerDeviceResults the results expected to be produced by each device ordered
   *                                 by the round when they are expected to be produced.
   * @param expectedVainSteps        the number of steps expected to produce no device exports
   *                                 at the end of the simulation.
   * @tparam A the type of results produced by the simulation.
   * @return the expected event log for a simulation.
   */
  private def expectedEventLog[A](
    expectedPerDeviceResults: Seq[A],
    expectedVainSteps: Int
  )(using
    simulation: Simulator.StepSimulation[A]
  ): Seq[Simulator.CollectiveResultMap[A]] =
    Seq.range(0, simulation.configuration.environment.nDevices)
      .flatMap(id => expectedPerDeviceResults.map(id -> _).zipWithIndex)
      .sortBy { case ((id, result), round) => (round, id) }
      .map { case ((id, result), round) => Map(id -> result) }
      .appendedAll(Seq.fill(expectedVainSteps)(Map()))

  private val maxSteps: Int = 20
  private val maxCount: Int = 10

  StepSimulator should behave like simulator(Simulator)

  it should "create a simulation that can be executed step-by-step" in stepSimulationTest(
    flow = count(from = 0, to = maxSteps),
    configuration = Simulator.StepSimulationConfiguration(EnvironmentWithTags(Environment.singleNode)),
    maxSteps = maxSteps,
    evaluation = eventLog =>
      eventLog.size shouldEqual maxSteps
      eventLog shouldEqual expectedEventLog(
        expectedPerDeviceResults = Seq.range(0, maxSteps),
        expectedVainSteps = 0
      )
  )

  it should
    "produce empty events when the execution of a step did " +
    "not produce any new device exports (vain step)" in stepSimulationTest(
    flow = count(from = 0, to = maxCount),
    configuration = Simulator.StepSimulationConfiguration(EnvironmentWithTags(Environment.singleNode)),
    maxSteps = maxSteps,
    evaluation = eventLog =>
      // note: `maxCount` is repeated twice by the `loop` flow because the underlying
      // export is different (prev in the loop changed), even though its result (the
      // root) is the same
      val expectedPerDeviceResults = Seq.range(0, maxCount) :+ maxCount :+ maxCount
      eventLog.size shouldEqual maxSteps
      eventLog shouldEqual expectedEventLog(
        expectedPerDeviceResults = expectedPerDeviceResults,
        expectedVainSteps = maxSteps - expectedPerDeviceResults.size,
      )
  )

  it should "execute a simulation with round-robin scheduling among the devices of the system" in stepSimulationTest(
    flow = count(from = 0, to = maxCount),
    configuration = Simulator.StepSimulationConfiguration(
      environment = EnvironmentWithTags(Environment.euclideanGrid(cols = 10, rows = 10)),
      haltPolicy = Simulator.HaltPolicy.haltOnVainStep
    ),
    evaluation = eventLog =>
      val nDevices = summon[Simulator.StepSimulation[?]].configuration.environment.nDevices
      eventLog
        .map(_.keys.headOption)
        .collect { case Some(deviceId) => deviceId }
        .foldLeft((Seq[(DeviceId, DeviceId)](), Option.empty[DeviceId])) {
          case ((bigrams, Some(prevId)), nextId) => (bigrams :+ (prevId, nextId), Some(nextId))
          case ((bigrams, None), nextId) => (bigrams, Some(nextId))
        }
        ._1
        .forall((prevId, nextId) => nextId == (prevId + 1) % nDevices)
        .shouldBe(true)
  )

  HaltOnVainStep should "terminate a simulation when a vain step is executed" in stepSimulationTest(
    flow = count(from = 0, to = maxCount),
    configuration = Simulator.StepSimulationConfiguration(
      environment = EnvironmentWithTags(Environment.singleNode),
      haltPolicy = Simulator.HaltPolicy.haltOnVainStep
    ),
    evaluation = _ shouldEqual expectedEventLog(
      expectedPerDeviceResults = Seq.range(0, maxCount) :+ maxCount :+ maxCount,
      expectedVainSteps = 1,
    )
  )

  HaltAfter should "terminate a simulation after specified amount of steps" in stepSimulationTest(
    flow = count(from = 0, to = maxCount),
    configuration = Simulator.StepSimulationConfiguration(
      environment = EnvironmentWithTags(Environment.singleNode),
      haltPolicy = Simulator.HaltPolicy.haltAfter(maxSteps)
    ),
    evaluation = eventLog =>
      val expectedPerDeviceResults = Seq.range(0, maxCount) :+ maxCount :+ maxCount
      eventLog shouldEqual expectedEventLog(
        expectedPerDeviceResults = expectedPerDeviceResults,
        expectedVainSteps = maxSteps - expectedPerDeviceResults.size,
      )
  )

  HaltWhen should "terminate a simulation after the collective system reaches a specific state" in stepSimulationTest(
    flow = count(from = 0, to = maxCount),
    configuration = Simulator.StepSimulationConfiguration(
      environment = EnvironmentWithTags(Environment.singleNode),
      haltPolicy = Simulator.HaltPolicy.haltWhen(_.get(0).forall(_ >= maxCount))
    ),
    evaluation = _ shouldEqual expectedEventLog(
      expectedPerDeviceResults = Seq.range(0, maxCount + 1),
      expectedVainSteps = 0
    )
  )
