package it.unibo.distributedfrp.frp

import it.unibo.distributedfrp.frp.StreamExtension.*
import it.unibo.distributedfrp.frp.timer.*
import it.unibo.distributedfrp.utils.Clock

import scala.concurrent.{Future, Promise}
import scala.concurrent.duration.FiniteDuration

/**
 * An extension for [[Stream Stream]]s to manipulate finite
 * [[Stream Stream]] of events.
 */
object FiniteStreamExtension:
  /**
   * A '''potentially''' finite [[Stream Stream]], whose end is
   * signalled to the user as an [[FiniteEvent.EOS EOS (End Of Stream)]]
   * event.
   *
   * Since all [[Stream Stream]]s are actually unlimited,
   * it isn't possible to prevent a [[Stream Stream]] from
   * generating new events. However, it is possible to model its
   * end too as an event, namely [[FiniteStreamEvent.EOS EOS]],
   * then discarding all the following events.
   */
  type FiniteStream[A] = Stream[FiniteEvent[A]]

  /**
   * An event generated by a [[FiniteStream FiniteStream]].
   *
   * A [[FiniteEvent FiniteEvent]] can be one of the following:
   *  - [[FiniteEvent.Event Event]]: an event with a specific payload.
   *  - [[FiniteEvent.EOS EOS (End Of Stream)]]: an event signalling
   *    the end of the [[FiniteStream FiniteStream]].
   */
  enum FiniteEvent[+A]:
    case Event(payload: A) extends FiniteEvent[A]
    case EOS extends FiniteEvent[Nothing]
  import FiniteEvent.{EOS, Event}

  extension [A](self: Stream[A]) {
    /**
     * @return a [[FiniteStream FiniteStream]] of the events
     *         of this [[Stream Stream]].
     * @note this is the entrypoint for configuring a [[FiniteStream FiniteStream]].
     * @example {{{
     *   s:        | 0    1    2    3    4    5    6    7    8    9
     *   s.finite: | E(0) E(1) E(2) E(3) E(4) E(5) E(6) E(7) E(8) E(9)
     *   --------------------------------------------------------------> t
     * }}}
     */
    def finite: FiniteStream[A] = self.map(Event(_))
  }

  extension [A](self: FiniteStream[A]){
    /**
     * @param predicate the specified predicate, as a [[PartialFunction]]. If the
     *                  predicate is not defined for a certain event, then it does
     *                  not hold for that event.
     * @return a new [[FiniteStream FiniteStream]] that ends each time the specified
     *         predicate holds.
     * @example {{{
     *   s:                        | E(0) E(1) E(2) E(3) E(4) E(5) E(6) E(7) E(8) E(9)
     *   s.finiteWhen(_ % 2 == 1): | E(0) EOS  E(2) EOS  E(4) EOS  E(6) EOS  E(8) EOS
     *   ------------------------------------------------------------------------------> t
     * }}}
     */
    private def finiteWhen(predicate: PartialFunction[A, Boolean]): FiniteStream[A] =
      self.map {
        case Event(payload) if predicate.isDefinedAt(payload) && predicate(payload) => EOS
        case finiteEvent => finiteEvent
      }

    /**
     * @param other the specified [[Stream Stream]].
     * @return a new [[FiniteStream FiniteStream]] that ends each time the
     *         specified [[Stream Stream]] fires an event.
     * @example {{{
     *   s1:              | E(0) E(1) E(2) E(3) EOS
     *   s2:              |           a    b        c
     *   s1.finiteBy(s2): | E(0) E(1) EOS  EOS  EOS EOS
     *   -----------------------------------------------> t
     * }}}
     */
    private def finiteBy(other: Stream[?]): FiniteStream[A] =
      other.mapTo(EOS).orElse(self)

    /**
     * @return a new [[FiniteStream FiniteStream]] obtained by discarding all
     *         the [[FiniteEvent FiniteEvent]]s of this [[FiniteStream FiniteStream]]
     *         following the first [[FiniteEvent EOS]].
     * @example {{{
     *   s:            | E(0) E(1) E(2) EOS E(3) EOS
     *   s.finiteOnce: | E(0) E(1) E(2) EOS
     *   --------------------------------------------> t
     * }}}
     */
    private def finiteOnce: FiniteStream[A] =
      self.collectLazy(false)((next, ended) =>
        if ended
        then (Option.empty, ended)
        else (Option(next), next == EOS)
      ).defined

    /**
     * @return a new [[FiniteStream FiniteStream]] obtained by
     *         considering only the [[FiniteEvent.Event Event]]s
     *         of this [[FiniteStream FiniteStream]].
     * @example {{{
     *   s:        | E(0) E(1) E(2) E(3) EOS
     *   s.events: | E(0) E(1) E(2) E(3)
     *   ------------------------------------> t
     * }}}
     */
    def events: FiniteStream[A] = self.filter(_ != EOS)

    /**
     * @return a new [[FiniteStream FiniteStream]] obtained by
     *         considering only the [[FiniteEvent.EOS EOS]] of
     *         this [[FiniteStream FiniteStream]].
     * @example {{{
     *   s:     | E(0) E(1) E(2) E(3) EOS
     *   s.eos: |                     EOS
     *   ---------------------------------> t
     * }}}
     */
    def eos: FiniteStream[A] = self.filter(_ == EOS)

    /**
     * @return a new empty [[Future]] completing when this
     *         [[FiniteStream FiniteStream]] fires its next
     *         [[FiniteEvent.EOS EOS]] event.
     * @note multiple call to this method will yield different
     *       instances of [[Future]]s.
     */
    def termination: Future[Unit] =
      val end: Promise[Unit] = Promise()
      self.eos.listenOnce(_ => end.success(()))
      end.future

    /**
     * @param mapper the specified mapping function.
     * @return a new [[FiniteStream FiniteStream]] obtained by applying
     *         the specified mapping function to the [[FiniteEvent.Event Event]]s
     *         of this [[FiniteStream FiniteStream]], leaving [[FiniteEvent.EOS EOS]]s
     *         untouched.
     * @example {{{
     *   s:                        | E(0) E(1) E(2)  E(3)   EOS
     *   s.mapPayload("a".repeat): | E()  E(a) E(aa) E(aaa) EOS
     *   -------------------------------------------------------> t
     * }}}
     */
    def mapPayload[B](mapper: A => B): FiniteStream[B] =
      self.map {
        case Event(payload) => Event(mapper(payload))
        case _ => EOS
      }

    /**
     * @param filter the specified filtering function.
     * @return a new [[FiniteStream FiniteStream]] obtained by applying
     *         the specified filtering function to the [[FiniteEvent.Event Event]]s
     *         of this [[FiniteStream FiniteStream]], leaving [[FiniteEvent.EOS EOS]]s
     *         untouched.
     * @example {{{
     *   s:                      | E(0) E(1) E(2) E(3) EOS
     *   s.filterPayload(_ > 1): |           E(2) E(3) EOS
     *   --------------------------------------------------> t
     * }}}
     */
    def filterPayload(filter: A => Boolean): FiniteStream[A] =
      self.filter {
        case Event(payload) if !filter(payload) => false
        case _ => true
      }

    /**
     * @param predicate the specified predicate, as a [[PartialFunction]]. If the
     *                  predicate is not defined for a certain event, then it does
     *                  not hold for that event.
     * @return a new [[FiniteStream FiniteStream]] that ends when the specified
     *         predicate holds.
     * @example {{{
     *   s:              | E(0) E(1) E(2) E(3) EOS
     *   s.until(_ > 1): | E(0) E(1) EOS
     *   s.until(_ > 5): | E(0) E(1) E(2) E(3) EOS
     *   ------------------------------------------> t
     * }}}
     */
    def until(predicate: PartialFunction[A, Boolean]): FiniteStream[A] =
      self.finiteWhen(predicate).finiteOnce

    /**
     * @param n the specified number of events.
     * @return a new [[FiniteStream FiniteStream]] ending when an
     *         event is fired after the specified number of events.
     * @example {{{
     *   s:           | E(0) E(1) E(2) E(3) EOS
     *   s.take(2):   | E(0) E(1) EOS
     *   s.take(10):  | E(0) E(1) E(2) E(3) EOS
     *   ---------------------------------------> t
     * }}}
     */
    def take(n: Int): FiniteStream[A] =
      self.zipWithIndex().finiteBefore(n)

    /**
     * @param duration the specified [[FiniteDuration]].
     * @return a new [[FiniteStream FiniteStream]] ending when an event is fired
     *         after the specified [[FiniteDuration]] has elapsed since the creation
     *         of the [[FiniteStream FiniteStream]].
     * @note the specified [[FiniteDuration]] is loosely enforced, meaning that the
     *       [[FiniteStreamEvent.EOS EOS]] will be sent only on the first event
     *       received after the specified [[FiniteDuration]], which may be never if no
     *       events are fired anymore.
     * @example {{{
     *   s:                  | E(0)    E(1)    E(2)    E(3)
     *   s.takeBefore(20ns): | E(0)    EOS
     *   s.takeBefore(50ns): | E(0)    E(1)    E(2)    E(3)
     *   ----------------------10ns----25ns----35ns----45ns----60ns----80ns-> t
     * }}}
     * @example {{{
     *   s:                  | E(0)    E(1)    E(2)    E(3)    EOS
     *   s.takeBefore(80ns): | E(0)    E(1)    E(2)    E(3)    EOS
     *   ----------------------10ns----25ns----35ns----45ns----60ns----80ns-> t
     * }}}
     */
    def takeBefore(duration: FiniteDuration)(using clock: Clock = Clock.SystemClock): FiniteStream[A] =
      self.zipWithTime().finiteBefore(duration)

    /**
     * @param duration the specified [[FiniteDuration]].
     * @return a new [[FiniteStream FiniteStream]] ending when an event is fired
     *         after the specified [[FiniteDuration]] has elapsed since the latest event.
     * @note the specified [[FiniteDuration]] is loosely enforced, meaning that the
     *       [[FiniteStreamEvent.EOS EOS]] will be sent only on the first event
     *       received after the specified [[FiniteDuration]], which may be never if no
     *       events are fired anymore.
     * @example {{{
     *   s:                              | E(0)    E(1)    E(2)    E(3)
     *   s.takeBeforeInactivityOf(20ns): | E(0)    E(1)    EOS
     *   s.takeBeforeInactivityOf(50ns): | E(0)    E(1)    E(2)    E(3)
     *   ----------------------------------10ns----25ns----50ns----60ns----70ns----100ns-> t
     * }}}
     * @example {{{
     *   s:                              | E(0)    E(1)    E(2)    E(3)    EOS
     *   s.takeBeforeInactivityOf(50ns): | E(0)    E(1)    E(2)    E(3)    EOS
     *   ----------------------------------10ns----25ns----50ns----60ns----70ns----100ns-> t
     * }}}
     */
    def takeBeforeInactivityOf(duration: FiniteDuration)(using clock: Clock = Clock.SystemClock): FiniteStream[A] =
      self.zipWithDelay.finiteBefore(duration)

    /**
     * @param other the specified [[Stream Stream]].
     * @return a new [[FiniteStream FiniteStream]] that ends when the specified
     *         [[Stream Stream]] fires an event.
     * @example {{{
     *   s1:                 | E(0) E(1) E(2) E(3) EOS
     *   s2:                 |           a    b
     *   s3:                 |                         0
     *   s1.interruptBy(s2): | E(0) E(1) EOS
     *   s1.interruptBy(s3): | E(0) E(1) E(2) E(3) EOS
     *   ------------------------------------------------> t
     * }}}
     */
    def interruptBy(other: Stream[?]): FiniteStream[A] =
      self.finiteBy(other).finiteOnce

    /**
     * @param duration the specified [[FiniteDuration]].
     * @param timerFactory a given [[TimerFactory]] for creating the [[Timer]] used to
     *        interrupt this [[FiniteStream FiniteStream]] after the specified
     *        [[FiniteDuration]]. The [[Timer]] will be created once and never reset.
     * @return a new [[FiniteStream FiniteStream]] ending after the specified
     *         [[FiniteDuration]] has elapsed since the creation of the [[FiniteStream FiniteStream]].
     * @example {{{
     *   s:                      | E(0)            E(1)    E(2)    E(3)    EOS
     *   s.interruptAfter(20ns): | E(0)    EOS
     *   s.interruptAfter(80ns): | E(0)            E(1)    E(2)    E(3)    EOS
     *   --------------------------10ns----20ns----25ns----35ns----45ns----60ns----80ns-> t
     * }}}
     */
    def interruptAfter(duration: FiniteDuration)(
      using timerFactory: TimerFactory[?] = TimerFactory.async
    ): FiniteStream[A] =
      self.interruptBy(timerFactory.create(duration).ticks)

    /**
     * @param duration the specified [[FiniteDuration]].
     * @param timerFactory a given [[TimerFactory]] for creating the [[Timer]] used to
     *                     interrupt this [[FiniteStream FiniteStream]] after the specified
     *                     [[FiniteDuration]]. The [[Timer]] will be created once and reset
     *                     at each event fired by this [[FiniteStream FiniteStream]].
     * @return a new [[FiniteStream FiniteStream]] ending after the
     *         specified [[FiniteDuration]] has elapsed since the latest event.
     * @example {{{
     *   s:                                  | E(0)    E(1)            E(2)    E(3)    EOS
     *   s.interruptAfterInactivityOf(20ns): | E(0)    E(1)    EOS
     *   s.interruptAfterInactivityOf(80ns): | E(0)    E(1)            E(2)    E(3)    EOS
     *   --------------------------------------10ns----25ns----45ns----50ns----60ns----70ns-> t
     * }}}
     */
    def interruptAfterInactivityOf(duration: FiniteDuration)(
      using timerFactory: TimerFactory[?] = TimerFactory.async
    ): FiniteStream[A] =
      val timer: Timer = timerFactory.create(duration)
      self.collectLazy(timer)((next, timer) => (next, timer.reset())).interruptBy(timer.ticks)
  }

  extension [A, Time: Ordering](self: Stream[(FiniteEvent[A], Time)]){
    /**
     * @param time the specified [[Time]].
     * @return a new [[FiniteStream FiniteStream]] that ends when an
     *         event is fired after the specified [[Time]] has elapsed.
     * @note the [[Time]] is modelled as a generic type with [[Ordering]].
     * @example {{{
     *   s:                  | (E(0),0) (E(1),1) (E(2),2) (E(3),3) (EOS,4)
     *   s.finiteBefore(2):  | E(0)     E(1)     EOS
     *   s.finiteBefore(10): | E(0)     E(1)     E(2)     E(3)     EOS
     *   ------------------------------------------------------------------> t
     * }}}
     * @example {{{
     *   s:                     | (E(0),10ns) (E(1),25ns) (E(2),35ns) (E(3),45ns) (EOS,60ns)
     *   s.finiteBefore(20ns):  | E(0)        EOS
     *   s.finiteBefore(100ns): | E(0)        E(1)        E(2)        E(3)        EOS
     *   ------------------------------------------------------------------------------------> t
     * }}}
     */
    private def finiteBefore(time: Time): FiniteStream[A] =
      self
        .map { case (Event(a), t) => Event((a, t)); case _ => EOS }
        .until(current => summon[Ordering[Time]].gteq(current._2, time))
        .mapPayload(_._1)
  }

